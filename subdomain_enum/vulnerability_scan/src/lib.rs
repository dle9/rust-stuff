// file operations
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

// port scan
use dns_lookup::lookup_host;
use std::io;
use std::net::IpAddr;

use util;

pub struct VulnerabilityScan {
    pub port_scan: PortScan,
}

pub struct PortScan {
    pub ports: Vec<(u16, PortState)>,
    pub total_time: std::time::Duration,
}

#[allow(dead_code)]
pub enum PortState {
    Open,
    Closed,
    Filtered,
}

#[allow(dead_code)]
impl PortScan {
    pub async fn run(_in: String) -> Self {
        PortScan {
            ports: Vec::new(),
            total_time: std::time::Duration::new(0, 0),
        }
    }

    async fn conduct_host_lookup(
        addr: &str,
    ) -> Result<(Vec<String>, std::time::Duration), io::Error> {
        let start_time = std::time::Instant::now();

        let ip_vecs: Vec<IpAddr> = lookup_host(addr).unwrap();
        let mut return_array: Vec<String> = vec![];

        for ip in ip_vecs {
            return_array.push(ip.to_string())
        }

        Ok((return_array, start_time.elapsed()))
    }
}

impl VulnerabilityScan {
    // ====================================== WRITE FUNCTIONS ==========================================
    pub fn write_all_results(&self) {
        // get+format data from all subdomain sources
        let port_scan_results = self.get_port_scan_results();

        // combine subdomain source outputs
        let mut all_results = String::new();
        all_results.push_str(&port_scan_results);

        // write all subdomain results into this main file
        self.write("src/output/scan.txt", all_results);

        // write singular results into individual files
        self.write_port_scan_results();
    }

    pub fn write_port_scan_results(&self) {
        let port_scan_results = self.get_port_scan_results();
        self.write("src/output/port_scan.txt", port_scan_results);
    }

    pub fn write(&self, filepath: &str, data: String) {
        let path = Path::new(filepath);
        let display = path.display();

        // open file in write only (File::create)
        let mut file = match File::create(&path) {
            Err(why) => panic!("Couldn't create {}: {}", display, why),
            Ok(file) => file,
        };

        // write to file
        match file.write_all(data.as_bytes()) {
            Err(why) => panic!("Couldn't write to {}: {}", display, why),
            Ok(_) => println!("Successfully wrote to {}", display),
        }
    }

    // ====================== GET+FORMAT FUNCTIONS ======================

    pub fn get_port_scan_results(&self) -> String {
        let res = util::format_title(
            format!("Open ports ({})", self.port_scan.ports.len()),
            // format!("{}", self.wordlist.subdomains.join("\n")),
            "todo: print open ports".to_string(),
        );

        return res;
    }

    pub fn display_summary(&self) {
        print!(
            "{}\n{}\n{}",
            // individual results
            format!(
                "Port scan records: Found {} open port(s) in {:?}",
                self.port_scan.ports.len(),
                self.port_scan.total_time
            ),
            // total results
            format!(
                "Total vulnerabilities found: {}",
                self.get_total_vulnerabilities()
            ),
            format!("Total time taken: {:?}", self.get_total_time()),
        );
    }



    // ========================================= HELPER FUNS =========================================
    fn get_total_vulnerabilities(&self) -> usize {
        return self.port_scan.ports.len();
    }

    fn get_total_time(&self) -> std::time::Duration {
        return self.port_scan.total_time;
    }
}
